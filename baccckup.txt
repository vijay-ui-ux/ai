import re
import nltk
from nltk.tokenize import word_tokenize
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
# Load model directly
from transformers import AutoModel
model = AutoModel.from_pretrained("DeepPavlov/distilrubert-base-cased-conversational")
try:
    nltk.data.find('tokenizers/punkt')
except LookupError:
    print("Downloading punkt tokenizer...")
    nltk.download('punkt')
    nltk.download('punkt_tab')

# Sample training data (replace with your own data)
training_data = [
    ("greeting", ["hello", "hi", "hey", "greetings", "good morning", "good afternoon", "good evening"]),
    ("farewell", ["bye", "goodbye", "see you later", "farewell", "take care"]),
    ("weather_inquiry", ["weather", "forecast", "temperature", "climate"]),
    ("food_inquiry", ["food", "cuisine", "eat", "hungry", "restaurant", "dish"]),
    ("italian_food", ["italian", "pasta", "pizza", "lasagna", "spaghetti"]),
    ("joke_request", ["tell me a joke", "make me laugh"]),
    ("time_inquiry", ["what time is it", "what's the time"]),
    ("calculator_addition", [r"(\d+) \+ (\d+)"]),  # Regex for addition
    ("calculator_subtraction", [r"(\d+) - (\d+)"]),  # Regex for subtraction
    ("general_question", [r"\?"])  # Matches any question mark
]

# Preprocess training data
corpus = []  # List to store all training sentences
labels = []  # Corresponding labels (intents)
for label, patterns in training_data:
    for pattern in patterns:
      if isinstance(pattern, str):  # Check if it's a string (not a regex)
        corpus.append(pattern)
        labels.append(label)

vectorizer = TfidfVectorizer()
X = vectorizer.fit_transform(corpus)  # TF-IDF matrix

def get_intent(user_input):
    user_input = user_input.lower()
    user_input_vec = vectorizer.transform([user_input])  # Transform user input
    similarity_scores = cosine_similarity(user_input_vec, X)  # Calculate similarities
    best_match_index = similarity_scores.argmax()  # Find index of best match
    return labels[best_match_index]  # Return the corresponding intent

def chatbot_response(user_input):
    intent = get_intent(user_input)

    if intent == "greeting":
        return "Hi there! How can I help you?"
    elif intent == "farewell":
        return "Goodbye! Have a great day."
    elif intent == "weather_inquiry":
        return "I'm not a weather expert, but you can check a weather app or website."
    elif intent == "food_inquiry":
        return "I love food! What kind of cuisine are you interested in?"
    elif intent == "italian_food":
        return "Ah, Italian! Have you tried the spaghetti carbonara or the Margherita pizza?"
    elif intent == "joke_request":
        return "Why don't scientists trust atoms? Because they make up everything!"
    elif intent == "time_inquiry":
        import datetime
        now = datetime.datetime.now()
        return "It's approximately " + now.strftime("%H:%M")
    elif intent == "calculator_addition":
      match = re.search(r"(\d+) \+ (\d+)", user_input)
      if match:
          num1 = int(match.group(1))
          num2 = int(match.group(2))
          return str(num1 + num2)
    elif intent == "calculator_subtraction":
      match = re.search(r"(\d+) - (\d+)", user_input)
      if match:
          num1 = int(match.group(1))
          num2 = int(match.group(2))
          return str(num1 - num2)
    elif intent == "general_question":
        return "That's a question! I'll do my best to answer, though my knowledge is limited."
    else:
        return "I'm still learning. I don't understand that yet. Perhaps rephrase?"

# Main loop
while True:
    user_input = input("You: ")
    if user_input.lower() in ["exit", "quit", "q"]:
        break
    response = chatbot_response(user_input)
    print("Chatbot:", response)